<!--
 * @Author: your name
 * @Date: 2020-09-28 15:03:04
 * @LastEditTime: 2020-09-28 16:47:47
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \记录-----笔记\JavaScript\Chrome v8垃圾回收.md
-->
### JS内存管理
在JS中，数据类型分为两类，简单类型和引用类型，对于简单类型，内存是保存在栈空间中，复杂数据类型，内存是保存在堆空间中。

基本类型：这些类型在内存中分别占有固定大小的空间，他们的值保存在栈空间中，通过值来访问的。
引用类型：值大小不固定，栈内存中存放地址指向堆内存中的对象。是按引用访问的。

由于栈的内存空间只保存简单数据类型的内存，由操作系统自动分配和自动释放。而堆内存中的内存空间，由于大小不固定，系统无法进行自动释放，这个时候就需要JS引擎来手动释放这些内存。

### V8内存限制
v8为什么要设置内存上限：
    1、JS单线程的执行机制
    2、JS垃圾回收机制
首先JS是单线程运行的，这意味着一旦进入到垃圾回收，那么其他的各种逻辑都要暂停（JS代码执行会一直没有响应，造成应用卡顿，导致应用性能和响应能力直线下降）；另一方面垃圾回收是非常耗时间的操作。
因此，V8做了一个选择就是限制堆内存。

### 为什么需要垃圾回收
栈内的内存，操作系统会自动进行内存分配和内存释放。而堆中的内存，由JS引擎（如Chrome的v8）手动进行释放。当我们的代码没有正确的写法时，会使得JS引擎的垃圾回收机制无法正确的对内存进行释放（内存泄漏），从而使得浏览器占用内存不断增加，进而导致JavaScript和应用、操作系统性能下降。

### 新生代内存回收
V8把堆内存分成了两部分进行处理--新生代内存和老生代内存，新生代内存就是临时分配的内存，存活时间短，老生代是常驻内存，存活时间长。V8的堆内存，也就是两个内存之和。
![1601281304(1)](./assets/image/1601281304(1).jpg)

根据这两种不同类的堆内存，V8采用了不同的回收策略，来根据不同的场景做针对性的优化。


#### 新生代垃圾回收
1、首先将新生代内存空间一分为二：
![1601281864(1)](./assets/image/1601281864(1).jpg)
其中`From`表示正在使用的内存，`To`表示目前闲置的内存。
当进行垃圾回收时，V8将From部分的对象检查一遍，如果是存活对象那么复制到To内存中（在To内存中按照顺序从头放置的），如果是非存活对象直接回收即可。
2、当所有的From中的存活对象按照顺序进入到To内存后，From和To两者的角色对调，From现在被闲置，To为正在使用，如此循环。

详见：https://juejin.im/post/6844903993420840967
